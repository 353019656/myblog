<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Rex657's Blog</title>
	<meta name="description" content="">
	<meta name="author" content="rex657">

	<!-- HTML5 shim, for IE6-8 support of HTML elements -->
	<!--[if lt IE 9]>
		<script src="https://rex657.github.io/blog/theme/html5.js"></script>
	<![endif]-->

	<!-- Styles -->
	<link href="https://rex657.github.io/blog/theme/bootstrap.min.css" rel="stylesheet">
	<link href="https://rex657.github.io/blog/theme/local.css" rel="stylesheet">
	<link href="https://rex657.github.io/blog/theme/pygments.css" rel="stylesheet">

	<!-- Feeds -->




</head>
<body>
	<div class="topbar">
	  <div class="topbar-inner">
		<div class="container-fluid">
		  <a class="brand" href="https://rex657.github.io/blog/">Rex657's Blog</a>
			<ul class="nav">
					<li ><a href="https://rex657.github.io/blog/category/python.html">Python</a></li>
					<li ><a href="https://rex657.github.io/blog/category/tutorial.html">Tutorial</a></li>
			</ul>
			<p class="pull-right"><a href="https://rex657.github.io/blog/archives.html">[archives]</a> <a href="https://rex657.github.io/blog/tags.html">[tags]</a></p>
		</div>
	  </div>
	</div>

	<div class="container-fluid">
	  <div class="sidebar">
		<div class="well">
			<h3>Blogroll</h3>
			<ul>
				<li><a href="https://docs.getpelican.com">Pelican Docs</a></li>
				<li><a href="http://python.org/">Python.org</a></li>
			</ul>
			<div class="social">
			<h3>Social</h3>
			<ul>
				<li><a href="#">Wechat: WTF353019656</a></li>
				<li><a href="https://rex657.giuhub.io">GitHub</a></li>
			</ul>
			</div>
		</div>
	  </div>
	  <div class="content">
<div class="page-header"><h1> Rex657's Blog </h1></div>
<div class='article'>
	<h2>Use Selenium to finish some tiring work</h2>
	<div class="well small">Permalink: <a class="more" href="https://rex657.github.io/blog/use-selenium-to-finish-some-tiring-work.html">2020-07-17 09:44:00+00:00</a>
by <a class="url fn" href="https://rex657.github.io/blog/author/rex657.html">Rex657 </a>
 in <a href="https://rex657.github.io/blog/category/tutorial.html">Tutorial</a>
tags: <a href="https://rex657.github.io/blog/tag/python.html">Python</a> <a href="https://rex657.github.io/blog/tag/automation.html">Automation</a> </div>
	<div class="summary"><h1>Selenium 助力完成网页自动化操作</h1>
<p>——————————————————————————————————————————————</p>
<h2>简介</h2>
<p>这里介绍一下如何使用python编写基于selenium的浏览器操作程序，从而实现浏览器页面的一些自动操作，包括打开表单，填入内容。这里不涉及如何构建完整的程序，只是将我个人在使用这个东西的时候的发现的一些有意思的点记录一下。</p>
<h2>Selenium</h2>
<p>这个程序会调用各种浏览器的"driver"程序，驱动浏览器完成一系列指定的操作，可以说是非常方便了。而且现在selenium也提供了对很多主流浏览器的支持，官方提到了"One interface to rule them all"，魔戒梗无疑了。官方文档声明这个程序主要是用于自动化操作网页实现自动化的测试，但也说明程序的用处不止于此。这个程序最经典的用处我想大概是前端开发人员在开发了新的网页平台后通过预设的selenium操作让测试机器自动完成一系列"点点点"的操作，并生成截图和文字的测试结果供查验，或者是产品打磨阶段基于用户的操作习惯模拟用户的一般操作，从而提前发现可能的bug。</p>
<h3>关于自动化测试</h3>
<p>现阶段的测试已经不再是那种一个测试人员走进酒吧点炒饭的时期了，很多公司的产品都是包装成一个精美的前端和对用户隐藏的后端系统构成的，而且很多时候还包含很多不同的功能，不同的子页面，重复式的测试已经不是主流，这也让使用到web元素的自动化测试具有非常广阔的应用前景。另外还包括selenium"剑走偏锋"的用途--网络爬虫。如果能在这些需要大量重复性工作的领域实现自动化，那一定可以很大程度上减少测试人员的负担，让测试能更多地把精力投入到报告bug的过程中去（另应该得防一下开发人员的"下班别走"了）。</p>
<h2>Browser-driver</h2>
<p>浏览器的driver程序是由官方直接提供的 …</p> <a class="btn primary xsmall" href="https://rex657.github.io/blog/use-selenium-to-finish-some-tiring-work.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Use PXE to install Windows NT</h2>
	<div class="well small">Permalink: <a class="more" href="https://rex657.github.io/blog/use-pxe-to-install-windows-nt.html">2020-07-17 09:41:00+00:00</a>
by <a class="url fn" href="https://rex657.github.io/blog/author/rex657.html">Rex657 </a>
 in <a href="https://rex657.github.io/blog/category/tutorial.html">Tutorial</a>
tags: <a href="https://rex657.github.io/blog/tag/pxe.html">PXE</a> <a href="https://rex657.github.io/blog/tag/win10.html">WIN10</a> </div>
	<div class="summary"><h1>使用PXE server引导安装Win10</h1>
<p>——————————————————————————————————————————————</p>
<h2>思路介绍</h2>
<p>之前研究过使用pxe技术进行自动化的linux发行版（主要是CentOS7系列）的安装，因为平时也会使用Win10，所以额外看了一下如何使用pxe引导安装win10。这里采用的方法颇有点曲线救国的意思，即先使用pxe引导WinPE，之后从WinPE挂载镜像或使用网络地址共享的安装文件启动安装程序，核心还是使用了WinPE的便捷引导。</p>
<p>我也尝试过直接使用pxe引导Win10的内核文件，但这种方式无法在系统安装程序开始后识别硬盘，估计是因为缺少了install.wim的驱动。</p>
<h2>准备步骤</h2>
<p>准备好对应版本的WinPE，如果你需要安装64位的系统，就需要准备64位的WinPE镜像，反之32位对应32位的WinPE，我则是两种都准备好了。</p>
<p>WinPE可以通过Windows ADK生成，Microsoft的文档库对这个步骤有较为详细的说明，我这里就不班门弄斧了，请移步下方链接查看制作WinPE.iso的步骤。</p>
<blockquote>
<p>https://docs.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/download-winpe--windows-pe  下载 WinPE (Windows PE)</p>
<p>https://docs.microsoft.com/zh-cn/windows-hardware/manufacture/desktop/winpe-create-usb-bootable-drive …</p></blockquote> <a class="btn primary xsmall" href="https://rex657.github.io/blog/use-pxe-to-install-windows-nt.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>How to build your openLDAP server</h2>
	<div class="well small">Permalink: <a class="more" href="https://rex657.github.io/blog/how-to-build-your-openldap-server.html">2020-07-17 09:40:00+00:00</a>
by <a class="url fn" href="https://rex657.github.io/blog/author/rex657.html">Rex657 </a>
 in <a href="https://rex657.github.io/blog/category/tutorial.html">Tutorial</a>
tags: <a href="https://rex657.github.io/blog/tag/ldap.html">LDAP</a> </div>
	<div class="summary"><h1>openLDAP安装和用户管理</h1>
<p>———————————————————————————————————————————————</p>
<h3>LDAP协议</h3>
<p>LDAP的全称为Lightweight Directory Access Protocol，一般被称为LDAP。LDAP本身是一种用于限定Client,server间信息交换格式，端口号和认证方式等内容的协议。LDAP的数据交换是基于TCP协议的，抓取的报文显示一次LDAP认证过程和一次https连接并没有太大的不同。这里是一个数据包的解析内容：</p>
<p><img alt="" src="https://i.loli.net/2020/06/28/YEH1ltWyhbgjzTN.png"></p>
<p>其中2.61是发起认证请求的client端，2.52是部署了openLDAP服务的LDAP服务器。目前使用较多的基于LDAP协议的应用，一种是Microsoft的AD，Active Directory，另一种就是Linux上的OpenLDAP服务，这里我们要介绍的是openLDAP服务器端的搭建流程。</p>
<h3>部署前准备</h3>
<p>部署环境为一台安装了CentOS7.2的服务器。提前给服务器配置好IP地址。</p>
<p>初始化环境时，安装如下软件包：</p>
<p><code>yum -y install openldap compat-openldap openldap-clients openldap-servers openldap-servers-sql openldap-devel</code></p>
<p>安装完成后启动服务</p>
<p><code>systemcrl start slapd</code></p>
<p><code>systemctl enable slapd</code></p>
<p>服务启动后查看ldap-server的默认端口389是否开启</p>
<p><img alt="" src="https://i.loli.net/2020/06/28/VHPMr2FjfRvdUJn.png"></p>
<p>一切正常的话，我们就可以进行接下来的服务配置了。</p>
<h3>服务配置</h3>
<p>openLDAP安装完成后会在默认安装路径 …</p> <a class="btn primary xsmall" href="https://rex657.github.io/blog/how-to-build-your-openldap-server.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Build a DNS Sniffer with scapy</h2>
	<div class="well small">Permalink: <a class="more" href="https://rex657.github.io/blog/build-a-dns-sniffer-with-scapy.html">2020-05-06 21:31:43+00:00</a>
by <a class="url fn" href="https://rex657.github.io/blog/author/rex657.html">Rex657 </a>
 in <a href="https://rex657.github.io/blog/category/python.html">Python</a>
tags: <a href="https://rex657.github.io/blog/tag/python.html">Python</a> <a href="https://rex657.github.io/blog/tag/scapy.html">Scapy</a> </div>
	<div class="summary"><h1>使用python的scapy模块打造DNS监控</h1>
<p>———————————————————————————————————————————————————————</p>
<h2>简介</h2>
<p>因为最近工作中有个需求是需要记录终端的dns请求，并进行对比和记录，这里研究了一下，使用python写了一个简单的本机dns请求的监控脚本。脚本设置后可以监控本机对特定域名的请求记录，以及记录这些dns请求的响应内容。用到了python一个看起来应用可以很广的（据我搜索的结果，可以使用这个模块进行本机的，好像并没有什么明显的意义，DNS欺骗）模块——scapy。本文只使用了这个模块的一小部分功能。</p>
<h3>Scapy</h3>
<p>Scapy是python一个非常强大的应用框架，可以非常方便的实现数据包的发送，嗅探，拆解和伪造（原文是forge，想了好几个词，不太确定要用生成和捏造...orz好像更奇怪了）数据包，可以用于编写对网络探测，扫描和攻击的工具。官方的介绍文档在这里：</p>
<blockquote>
<p>https://scapy.readthedocs.io/en/latest/ --scapy official documentation</p>
</blockquote>
<p>我在自己的python 3.7环境下使用pip安装了scapy[basic]</p>
<p><code>pip install --pre scapy[basic]</code></p>
<p>这里因为时间比较赶，直接使用了官方的推荐安装方式（这种做法以后还是少一点好 …</p> <a class="btn primary xsmall" href="https://rex657.github.io/blog/build-a-dns-sniffer-with-scapy.html">more…</a>
	</div>
</div>	
<div class='article'>
	<h2>Build a Cobbler in Docker Container</h2>
	<div class="well small">Permalink: <a class="more" href="https://rex657.github.io/blog/build-a-cobbler-in-docker-container.html">2020-04-30 10:14:00+00:00</a>
by <a class="url fn" href="https://rex657.github.io/blog/author/rex657.html">Rex657 </a>
 in <a href="https://rex657.github.io/blog/category/tutorial.html">Tutorial</a>
tags: <a href="https://rex657.github.io/blog/tag/docker.html">Docker</a> <a href="https://rex657.github.io/blog/tag/cobbler.html">Cobbler</a> <a href="https://rex657.github.io/blog/tag/automation.html">Automation</a> </div>
	<div class="summary"><h1>使用Docker容器部署Cobbler服务</h1>
<p>———————————————————————————————————————————————————————</p>
<h2>简介</h2>
<p>Cobbler是基于Python语言编写的批量引导平台，其特点在于可以支持不同的系统镜像，同时基于pxe网络引导执行自动化系统安装。本文档制作意在指导操作者使用容器技术搭建易用和快速部署的Cobbler服务。
要顺利使用此文档，请提前参阅了解docker技术，kickstart技术和PXE网络引导。
有意思的是，百度百科将cobbler介绍为：Cobbler 可以用来快速建立 Linux 网络安装环境，它已将 Linux 网络安装的技术门槛，从大专以上文化水平，成功降低到初中以下，连补鞋匠都能学会。</p>
<blockquote>
<p>Note: 不过我在后期的实际使用中发现，docker容器部署的方式在没有简化image的情况下，易用性不如直接安装服务好。这里给自己留个坑，一是在此版本的部署基础上继续优化镜像大小，二是继续调整容器部署方式。</p>
</blockquote>
<p>其实我本人做这个事的目的是刚好练一下手，去再熟悉一下docker容器，敲定了思路以后在网上去找了一些资料，文章最后我会把参考资料也附上。</p>
<h2>准备</h2>
<p>首先你得先安装docker，在你本地先执行</p>
<p><code>yum -y install epel-release vim net-tools docker</code></p>
<p>我测试的时候使用的最小化安装所以额外还装了一些工具，主要的还是docker。</p>
<p>安装好了以后先启动docker, 我在使用centos7.2的时候在这一步遇到了报错：</p>
<p><code>Error starting daemon …</code></p> <a class="btn primary xsmall" href="https://rex657.github.io/blog/build-a-cobbler-in-docker-container.html">more…</a>
	</div>
</div>	

<div class="pagination">
<ul>
		<li class="prev disabled"><a href="#">&larr; Previous</a></li>
		<li class="active"><a href="https://rex657.github.io/blog/index.html">1</a></li>
		<li class=""><a href="https://rex657.github.io/blog/index2.html">2</a></li>
		<li class="next"><a href="https://rex657.github.io/blog/index2.html">Next &rarr;</a></li>
</ul>
</div>

		<footer>
		  <p>Powered by <a href="http://getpelican.com/">Pelican</a>. Theme based on <a href="http://twitter.github.com/bootstrap/">Twitter Bootstrap</a>.</p>
		  <p>&copy; rex657</p>
		</footer>
	  </div>

	</div>
</body>
</html>